\chapter{Introduction}

The constant presence of software systems in our every day lives has become one incontestable truth, they are everywhere from our personal devices such as computers and smartphones to systems controlling transactions of banks and e-commerce. Software even powers airplanes and air traffic, traffic lights, medical instruments, highways and building design, among several other applications that may endanger lives if something goes wrong.

Regarding this ubiquitous presence of software, one of the biggest concerns in the industry is how to assure the quality of the products that are delivered, guaranteeing they will behave as intended to and will not crash under unexpected circumstances~\cite{Ammann2008}.

There are several approaches that aim to address this issue, for example: software testing, static analysis, model checking, mathematical proofs, etc. Amongst them, the current dominant approach in industry is software testing, which is not as powerful as the others, but it is significantly cheaper to use and requires a lot less specific knowledge and tools~\cite{Meyer2008, Utting2006}.

Software testing is an empirical process that aims to find and avoid bugs as early as possible in the development process. From a practical point of view, testing is a controlled execution of a specific piece of a system: it receives an input, executes a selected subset of features and then decides whether the behaviour of the system was consistent or not. However, software testing can not prove correctness of a system nor the absence of bugs. The main reason why is that there is an infinite
amount of possible inputs a system can receive, therefore there is no possible way to systematically check all underlying executions in a finite amount of time.

Since it is not possible to thoroughly test a complex, real system, test designers usually try to write meaningful sets of tests covering the most important cases they can think of. Besides those cases designed prior to the execution, tests cases must also (ideally) cover all previously known bugs, maybe extending them with random generated data. Furthermore, whenever a new bug is found during development or usage, the test cases must be updated accordingly.

In order to automatically and unambiguously decide whether a test failed or succeeded, test designers also need to specify test oracles. Test oracles are specifications that may, for example, describe the relationship between the input given and the expected output, describe valid and invalid data properties, possible execution paths, etc. No matter the oracle format, it must be able to check the validity of tests in a \textit{reasonable} amount of time~\cite{Weyuker1982}.

Designing significant test cases and oracles is a hard and time consuming task, prone to errors similar to those of the analysis and development activities. One possible way to mitigate this issue is by using a model-based testing approach, where test designers or analysts use an abstract model of the system to generate tests~\cite{Utting2006}. These models can be written prior to software development and testing or extracted from the source code by proper tools and checked against some form of specification.

\newadd{There are several computational models that can be used for model-based testing, such as graph grammars~\cite{Baldan2004}, B~\cite{Abrial1996}, UML Object Constraint Language (OCL)~\cite{Warmer2003}, VDM~\cite{Jones1990}, Labelled Transition Systems~\cite{Tretmans1996}, CSP~\cite{Nogueira2008}, among others. In this work, we will make use of the Graph Grammars framework.}

Graph grammars are a suitable formalism to model complex systems in an intuitive and precise manner, possessing both a graphic notation and a solid formal background. \newadd{System states are modelled as graphs, while transitions between different states are modelled as graph transformation rules.} Using them it is not only possible to simulate the execution of the modelled system, but also analyse several properties about its behaviour, such as termination, concurrency, reachable states, among others~\cite{Ehrig2006}.

\newadd{Several non-trivial systems have been modelled and studied under the optics of graph grammars, such as telephone communications~\cite{Ribeiro1996}, elevator and railroad control~\cite{Lambers2010, Pennemann2009}, to cite just a few.}

Furthermore, it is possible for non-specialists in the field to generate graph grammars from a set of textual requirement documents such as use cases, functional specifications and other kinds of guidelines by means of a systematic, computer-aided methodology~\cite{Junior2015,BezerraWEIT2016,Cota2017}.

We believe that the use of graph grammars as a model for the generation of test cases and oracles may improve the reliability of the testing activity by using the solid formal semantics of the formalism, while requiring little theoretical expertise from the user. The main objective of this thesis can be summarized as follows:

\begin{intuition}
  \center{\textit{Given the graph grammar model of a software system, how can a set of relevant test cases and oracles be generated for the system?}}
\end{intuition}\hfill\break

Where by \emph{relevant} we mean (1) a set of test oracles capable of deciding, for any input, which paths of execution and which states of the system are valid: \textbf{verifiability}; (2) a set of tests covering all as many flows of execution as feasible: \textbf{coverage}; while (3) tests avoid repetition of equivalent paths: \textbf{compactness}.

The concepts and ideas developed during this work will also be implemented in Verigraph~\cite{verigraph,Costa2016}, a new system for specification and verification of software that is based on graph grammars and category theory.

\important{Explain better that we are generating tests for graph grammars: more theory, less software engineering.}

\newadd{The main contributions of this thesis are (1) the development of a strategy for the generation of test cases from graph grammars, which required (2) an extension of the Occurrence Graph Grammar framework in order to allow the tests generation for complex, realistic systems modelled as graph grammars. Finally, (3) the implementation of this strategy in the Verigraph System.}

\hfill \break
\textbf{Structure of the Thesis:}

\begin{description}
  \item[Chapter~\ref{ch:gts}:] In this chapter we review the basic notions of Double-Pushout (DPO) graph transformation systems, as well as the notions of parallel and sequential independency of rules.

\iffalse
  \item[Chapter~\ref{ch:concurrent-rules}:] In this chapter we present the construction of concurrent rules in addition to the problems that may arise from their calculation. Moreover, we present techniques that can be used to work around the problems.
\fi

  \item[Chapter~\ref{ch:process}:] In this chapter we present an overview of doubly-typed graph grammars and other constructions necessary to accomplish occurrence graph grammars, and how occurrence graph grammars can be used to represent the concurrent semantics of a graph grammar.

    We also extend previous works in occurrence graph grammars to include the notion of negative application conditions, which are commonly used in the modelling of systems as graph transformations systems nowadays.

  \item[Chapter~\ref{ch:verigraph}:] This chapter presents an overview of the Verigraph system, which was used to implement implement the techniques presented in this thesis.

  We present its architecture and novelty, as well as its suitability to deal with the problem domain in an elegant fashion.

  \item[Chapter~\ref{ch:tests}:] This chapter briefly reviews a methodology to extract graph grammar models from the use use cases of a system. Furthermore, we provide a strategy to extract test cases from calculated occurrence graph grammars, which is implemented in Verigraph, and argue about the relevance of the generated set of tests.

  \item[Chapter~\ref{ch:related-work}:] In this chapter, we compare our approach to similar works found in the literature, focusing both on tools for modelling and analysing graph grammars and on the generation of test cases based on models and formal methods. \important{review}

  \item[Chapter~\ref{ch:conclusions}:] This chapter summarizes our results and presents the conclusions. Moreover, it shows remaining open problems and future work.

  \item[Appendix~\ref{app:category-theory}:] This appendix contains a brief introduction to category theory and the categorial constructions used in this thesis.

  \item[Appendix~\ref{app:tutorial}:] This appendix contains the Verigraph manual, explaining in the details how the system can be downloaded, installed and used.

  \item[Appendix~\ref{app:use-cases}] This appendix contains the use cases and modelled graph grammar used as case study on section~\ref{ch:tests}.
\end{description}
