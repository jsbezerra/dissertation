\chapter{Introduction}

Testing does not prove the software to be correct, but it helps to find bugs.

Write significant tests is hard and time consuming.

How to help the engineers to generate a good set of test cases?

We want to generate a set of test cases that:

\begin{itemize}
  \item covers all possible paths of execution: \textbf{completeness};
  \item avoids repetition of equivalent paths due to concurrency: \textbf{compactness}.
\end{itemize}

\section{Thesis aims}

The main objective of this thesis is to address the following problem:

\begin{intuition}
  \textit{Given a graph grammar that models a system, how to generate a set of test cases that covers all possible paths of the system's execution avoiding repetition of equivalent paths.}
\end{intuition}

To what we propose the following approach:

\begin{enumerate}
  \item
  \item
\end{enumerate}

\hfill \break
\textbf{Structure of the Thesis:}

\begin{description}
  \item[Chapter~\ref{ch:gts}:] In this chapter we present a brief introduction to category theory, focusing on the constructions the will be needed throughout this work.  We also review the basic notions of DPO graph transformation systems, as well as the notions of parallel and sequential independency of rules.

\iffalse
  \item[Chapter~\ref{ch:concurrent-rules}:] In this chapter we present the construction of concurrent rules in addition to the problems that may arise from their calculation. Moreover, we present techniques that can be used to work around the problems.
\fi

  \item[Chapter~\ref{ch:process}:] In this chapter we present an overview of doubly-typed graph grammars and other constructions necessary to accomplish occurrence graph grammars, and how occurrence graph grammars can be used to represent the concurrent semantics of a graph grammar.

    We also extend previous works in occurrence graph grammars to include the notion of negative application conditions, which are commonly used in the modelling of systems as graph transformations systems nowadays.

  \item[Chapter~\ref{ch:verigraph}:] This chapter presents an overview of the verigraph tool, which was used to implement implement the techniques presented in this thesis. Both the reviewed on chapter~\ref{ch:gts} and presented on ~\ref{ch:process}.

  We present its architecture and novelty, as well as its suitability to deal with the problem domain in an elegant fashion.

  \item[Chapter~\ref{ch:tests}:] This chapter briefly introduces a methodology to extract graph grammar models from the use use cases of a system, after what it presents how we can use the concepts explained in previous chapters to generate a set of test cases.

    Specifically, we show how to extract test cases from calculated occurrence graph grammars, which was implemented on verigraph, and the reasons why the generated set of tests are relevant.

  \item[Chapter~\ref{ch:related-work}:] In this chapter, we present and compare our work to similar works found in the literature, focusing on the generation of test cases based on models and formal methods.

  \item[Chapter~\ref{ch:conclusions}:] This chapter summarizes our results and presents the conclusions. Moreover, it shows remaining open problems and future work.

  \item[Appendix~\ref{app:tutorial}:] This appendix contains the verigraph manual, explaining in the details how the tool can be downloaded, installed and used.

  \item[Appendix~\ref{app:marvel-grammar}] This appendix contains the use cases and modelled graph grammar used as case study on section~\ref{ch:tests}.
\end{description}
