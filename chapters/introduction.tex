\chapter{Introduction}

Graph grammars are a suitable formalism to model complex systems in an intuitive and precise manner, providing both a graphical, straightforward language and a solid formal background for systems analysis. In this framework, system states are modelled as graphs, while transitions between different states are modelled as graph transformation rules~\cite{Ehrig2006}. A graph transformation rule generically has the form $L \xRightarrow{p} R$, where we have at least one left side $L$ containing a pattern which must be found (a match) for the rule to be applied over an instance graph and a right side $R$ corresponding to the effect of applying such a rule.

There exist several approaches that may slightly change the exact format of a rule, but, more important, define different ways in whether and how a rule can be applied over a given match, for example: the Single Pushout (SPO), Double Pushout (DPO), Sesqui-Pushout (SqPO), AGREE, among others. Nonetheless, there are also additional structures that may be used as complements of rules to restrict even more which kinds of matches are acceptable to perform a transformation, such as: Graph Constraints, Negative Application Conditions (NACs) and Nested Application Conditions, to cite only the most commonly used within the realm of Category Theory.

Each approach has its own advantages/disadvantages regarding the underlying set of  ``operations'' they allow or forbid in the system under modelling, but whichever approach is used, they all provide a way to simulate the execution of the system together with means to analyse several properties about its behaviour, such as termination, concurrency and reachable states. Among the analysis techniques provided by graph grammars, we have:

\begin{itemize}
  \item Critical Pair Analysis and Critical Sequence Analysis: the first one allows us to verify which rules conflict with (i.e. prohibit) the application of another and why; the second, which rules depend on the execution of others to be applied and why~\cite{Lambers2008a};
  \item Calculation of Concurrent Rules: summarizes in one rule the combined results of applying several different rules. In other words, it presents several partial executions given by a set of rules as a ``one step'' execution~\cite{Lambers2008,BezerraETMF2016}.
  \item State Space Exploration and Model Checking; \important{complete}~\cite{Rensink2004}
  \item Unfolding, Graph Processes, Occurrence Graph Grammars and Canonical Derivations; \important{complete}~\cite{Corradini1996,Ribeiro1996}
\end{itemize}

Given such properties, graph grammars have found a wide range of applications within Computer Science, specially in the field of model-driven software development, where the transformation of visual models is a vital part of the process, therefore a natural application of graph grammars~\cite{Rozenberg1997}. As proof of such suitability, several non-trivial systems have been modelled and studied under the optics of graph grammars, such as telephone communications~\cite{Ribeiro1996}, elevator control~\cite{Lambers2010}, railroad control~\cite{Pennemann2009} and integration of service-oriented systems~\cite{Giese2015}, to cite just a few. Furthermore, there exist also a range of software tools to support the use of graph grammars, such as AGG, a tool environment for algebraic graph transformation~\cite{Taentzer2000}; Groove, a tool for state space generation~\cite{Rensink2004} and Verigraph, a software specification and verification tool based on graph rewriting~\cite{verigraph}.

Besides its powerful applications, the use of graph grammars as a framework for modelling systems provides us with a great advantage over other formalisms: it makes possible for non-specialists in the field to generate graph grammar models of a system and still benefit from the rigorous analyses it offers. For example, ~\cite{Junior2015,BezerraWEIT2016,Cota2017} explain how to generate graph grammars from a set of textual requirement documents such as use cases, functional specifications and other kinds of guidelines by means of a systematic methodology. They also present guidance towards using different graph grammars analysis techniques in order to improve and verify these documents and, consequently, the systems they describe.

The field of graph grammars is a very active one, and researches continuously come up with new graph transformation approaches (e.g. Sesqui-Pushout, AGREE), analysis techniques (e.g. Essential Critical Pairs) and ways to apply them. We also may benefit from the combination of already existing techniques. In this thesis, we combine two of such techniques: Occurrence Graph Grammars, defined for the SPO and DPO approach by~\cite{Ribeiro1996, Corradini1996}, with Negative Application Conditions, defined generically by~\cite{Habel1996}, which has not been done so far. 

Occurrence Graph Grammars provides us the semantics of graph grammars encoded in structures that are also graph grammars themselves. This semantics, which tells us which graphs are part of the grammar language and which graph transformations are possible within the context of the grammar, may be used for the analysis of the system execution in a summarized fashion and also be used for practical applications, such as test cases generation, without the necessity to use a different kind of structure or formalism.

Negative Application Conditions are extensions of rules which encode patterns that, although found in the match of a rule, are forbidden in the context of the transformation. In theory, they do not give any more expressive power to a graph grammar then when using only rules without them, however in practice they allow the modelling of systems in a much more concise and compact manner. Therefore they became really necessary in the modelling of complex, real-like systems.

Alongside with the development of the underlying theory for our extension, we also implemented it in the Verigraph System, a generic graph rewriting system based on Category Theory and written in Haskell. This implementation choice makes possible for the source code of the tool to be very close to the theory domain as well as allowing other researches to implement new approaches or different models of graphs while benefiting from the already existing techniques (as long as they conform to the categorial constructions).

%We believe that the use of graph grammars as a model for the generation of test cases and oracles may improve the reliability of the testing activity by using the solid formal semantics of the formalism, while requiring little theoretical expertise from the user. The main objective of this thesis can be summarized as follows:

%\begin{intuition}
%  \center{\textit{Given the graph grammar model of a software system, how can a set of relevant test cases and oracles be generated for the system?}}
%\end{intuition}\hfill\break

Thus, the main contributions of this thesis are summarized as (1) the creation of an extension  to the framework of Occurrence Graph Grammars (using the DPO approach) in order to include Negative Application Conditions, therefore allowing for the semantic analysis of more complex, realistic systems and (2) the implementation of this extension in Verigraph, a software specification and verification system based on graph transformations.

\hfill \break
\textbf{Structure of the Thesis:}

\begin{description}
	\item[Chapter~\ref{ch:gts}:] In this chapter we review the basic notions of graph transformation systems, specifically under the Double-Pushout (DPO) approach. We also introduce Negative Application Conditions (NACs) and the notions of parallel and sequential independency of rules, which will be used later on.

  \item[Chapter~\ref{ch:process}:] In this chapter we first present an overview of doubly-typed graph grammars and other constructions necessary to accomplish occurrence graph grammars. Also, how these Occurrence Grammars can be used to represent semantics of their original grammar.

    After that, we present our extension to previous works in Occurrence Graph Grammars to include the notion of Negative Application Conditions, which is part of our thesis contribution.

  \item[Chapter~\ref{ch:verigraph}:] This chapter presents an overview of the Verigraph system, which was used to implement implement the techniques presented in this thesis. Verigraph in itself represents a novelty in the field of graph transformations, being the first tool implemented in a functional language, which favored its source code to be very close to the problem domain itself.

  \item[Chapter~\ref{ch:tests}:] This chapter explains in depth how the construction of Occurrence Graph Grammars for a given Graph Grammar was implemented in Verigraph, while also providing some insight about how it can be used for test cases generations. \tinytodo{colar no cap√≠tulo do verigraph?}

  \item[Chapter~\ref{ch:conclusions}:] This chapter presents some related work, then summarizes our results and presents our conclusions. Moreover, it shows remaining open problems and future work.

  \item[Appendix~\ref{app:category-theory}:] This appendix contains a brief review of category theory and the categorial constructions used in this thesis.

  %\item[Appendix~\ref{app:use-cases}] This appendix contains the use cases and modelled graph grammar used as case study on section~\ref{ch:tests}.
\end{description}
