\chapter{Introduction}

Graph grammars are a suitable formalism to model complex systems in an intuitive and precise manner, providing both a graphical straightforward language and a solid formal background for system analysis. In this framework, (computational) system states are modelled as graphs, while transitions between different states are modelled as graph transformation rules. By using them it is possible to simulate the execution of a modelled system and also analyse several properties about its behaviour, such as termination, concurrency, reachable states, among others~\cite{Ehrig2006}. Among the analysis techniques provided by graph grammars, we have:

\begin{itemize}
  \item Critical Pairs and Critical Sequences Analyzes; the first one allows us to verify which rules conflict (i.e. prohibit) the application of another and why; the second, which rules depend on the execution of others to be applied and why~\cite{Lambers2008a}; 
  \item Calculation of Concurrent Rules; which summarizes the results of applying several different rules in only one rule; 
  \item State Space Exploration and Model Checking; \important{complete}
  \item Unfolding, Graph Processes and Canonical Derivations; \important{complete}
\end{itemize}

\important{[Small, trivial examples to easy the explanation]}

Given such properties, graph grammars have found a wide range of applications within Computer Science, specially in the field of model-driven software development, where the transformation of visual models is a vital part of the process and additionally a natural application of graph grammars~\cite{Rozenberg1997}. As proof of such suitability, several non-trivial systems have been modelled and studied under the optics of graph grammars, such as telephone communications~\cite{Ribeiro1996}, elevator and railroad control~\cite{Lambers2010, Pennemann2009} and integration of service-oriented systems~\cite{Giese2015}, to cite just a few.

Besides its powerful applications, the use of graph grammars as a framework for modelling systems provides us with a great advantage over other formalisms: it makes possible for non-specialists in the field to generate graph grammar models of a system and still benefit from the rigorous analyzes it offers. For example, ~\cite{Junior2015,BezerraWEIT2016,Cota2017} explain how to generate graph grammars from a set of textual requirement documents such as use cases, functional specifications and other kinds of guidelines by means of a systematic methodology. They also present guidance towards using different graph grammars analysis techniques in order to improve and verify these documents and, therefore, the systems they describe.

In this work, we are concerned about the semantics of graph grammars\ldots

\important{Graph grammars and their semantics}

\important{What is the semantics of a graph grammar?}

\important{Why is it important?}

\important{How can it be obtained using Occurrence Graph Grammars}

We believe that the use of graph grammars as a model for the generation of test cases and oracles may improve the reliability of the testing activity by using the solid formal semantics of the formalism, while requiring little theoretical expertise from the user. The main objective of this thesis can be summarized as follows:

\begin{intuition}
  \center{\textit{Given the graph grammar model of a software system, how can a set of relevant test cases and oracles be generated for the system?}}
\end{intuition}\hfill\break

Where by \emph{relevant} we mean (1) a set of test oracles capable of deciding, for any input, which paths of execution and which states of the system are valid: \textbf{verifiability}; (2) a set of tests covering all as many flows of execution as feasible: \textbf{coverage}; while (3) tests avoid repetition of equivalent paths: \textbf{compactness}.

The concepts and ideas developed during this work will also be implemented in Verigraph~\cite{verigraph,Costa2016}, a new system for specification and verification of software that is based on graph grammars and category theory.

\important{Explain better that we are generating tests for graph grammars: more theory, less software engineering.}

\newadd{The main contributions of this thesis are (1) the development of a computer-aided strategy for the generation of test cases from graph grammars, which required (2) an extension of the Occurrence Graph Grammar framework in order to allow the tests generation for complex, realistic systems modelled as graph grammars. Finally, (3) the implementation of this strategy in the Verigraph System.}

\hfill \break
\textbf{Structure of the Thesis:}

\begin{description}
  \item[Chapter~\ref{ch:gts}:] In this chapter we review the basic notions of graph transformation systems, specifically under the Double-Pushout (DPO) approach, as well as the notions of parallel and sequential independency of rules.

  \item[Chapter~\ref{ch:process}:] In this chapter we present an overview of doubly-typed graph grammars and other constructions necessary to accomplish occurrence graph grammars. Also, how these occurrence grammars can be used to represent the concurrent semantics of their original grammar.

    We also present out extension to previous works in occurrence graph grammars to include the notion of negative application conditions, which is part of our thesis contribution.

  \item[Chapter~\ref{ch:verigraph}:] This chapter presents an overview of the Verigraph system, which was used to implement implement the techniques presented in this thesis. Verigraph in itself represents a novelty in the field of graph transformations, being the first tool implemented in a functional language, which favored its source code to be very close to the problem domain itself.

  \item[Chapter~\ref{ch:tests}:] This chapter briefly reviews a methodology to extract graph grammar models from the use use cases of a system. Furthermore, we provide a strategy to extract test cases from calculated occurrence graph grammars, which is implemented in Verigraph, and argue about the relevance of the generated set of tests.

  \item[Chapter~\ref{ch:conclusions}:] This chapter presents some related work, then summarizes our results and presents our conclusions. Moreover, it shows remaining open problems and future work.

  \item[Appendix~\ref{app:category-theory}:] This appendix contains a brief introduction to category theory and the categorial constructions used in this thesis.

  \item[Appendix~\ref{app:tutorial}:] This appendix contains the Verigraph manual, explaining in the details how the system can be downloaded, installed and used.

  \item[Appendix~\ref{app:use-cases}] This appendix contains the use cases and modelled graph grammar used as case study on section~\ref{ch:tests}.
\end{description}
