\chapter{Introduction}

The constant presence of software systems in our every day lives has become one incontestable truth, they are everywhere from our personal devices such as computers and smartphones to systems controlling transactions of banks and e-commerce. Software even powers airplanes and air traffic, traffic lights, medicine instruments, highways and building design, among several other applications.

Regarding this ubiquitous presence of software, one of the biggest concerns in the software industry is how to assure the quality of the products that are delivered, guaranteeing that it will behave as intended to and that they will not crash under unexpected circumstances~\cite{Ammann2008}.

There are several approaches that aim to address this issue, for example software testing, static analysis, model checking, mathematical proofs, etc. Amongst them, the current dominant approach in industry is software testing, which is not as powerful as the others, but it is significantly cheaper to use and requires a lot less of specific knowledge and tools~\cite{Meyer2008, Utting2006}.

Software testing is an empirical process that can not prove the correctness of a software, instead it helps finding bugs that would otherwise remain unknown until later phases of the software development or usage. In a practical point of view, the testing activity can be regarded as a controlled execution of a specific piece of a system: a test receives an input, executes a selected subset of features of a system according to it and then produces a report of whether the behaviour of a system was consistent or not. 

The main reason why the testing approach can not prove correctness is that there is a virtually infinite amount of possible inputs a system can receive, therefore there is no possible way to systematically apply to all of them in a finite amount of time.

In practice, test designers usually try to write meaningful sets of tests that cover the most important cases they can think of, ideally with cases covering previously known bugs, and extend them with random generated data. Also, whenever a new bug is found during development or usage the test cases must be updated accordingly.

In order to automatically and unambiguously decide whether a test failed or succeeded, test designers also need to specify test oracles. Test oracles are specifications that may, for example, describe properties about the relationship between the input given and the output expected, describe valid and invalid data properties, possible paths execution, etc. No matter the oracle format used it must be able to check the validity of tests in a \textit{reasonable} amount of time~\cite{Weyuker1982}.

However, designing significant test cases and oracles is a hard and time consuming task, prone to errors similar to those of the analysis and development activities. One possible way to address this issue is the use of a model-based testing approach, where the test designers or analysts use an abstract model of the system to generate the tests from it~\cite{Utting2006}. 

These models can be written prior to the software development and testing or extracted from the source code with the use of proper tools and checked against some form of specification. There are several models in which this approach can be used, one of them are graph grammars.

Graph grammars are a suitable formalism to model complex systems in a intuitively and precise manner, in which is possible not only to simulate the execution of the modelled system, but also analyse several properties about its behaviour, such as termination, concurrency, reachable states, among others~\cite{Ehrig2006}.

Furthermore, it is possible for non-specialists in the field to generate graph grammars from a set of textual requirement documents such as use cases, functional specifications and other kinds of guidelines by means of a systematic, computer-aided methodology~\cite{Junior2015,BezerraWEIT2016,Cota2017}.

We believe that the use of graph grammars as a model for test cases and oracles generation may improve the reliability of the testing activity by using the semantics of the formalism. The main objective of this thesis can be summarized as follows:

\begin{intuition}
  \center{\textit{Given the graph grammar model of a software system, how to generate a set of relevant test cases and oracles for the system itself?}}
\end{intuition}\hfill\break

Where by \emph{relevant} we mean that (1) the set of test oracles must be capable of deciding, for any input, which paths of execution and which states of the system are valid: \textbf{verifiability}; (2) the set of tests must cover all possible flows of execution: \textbf{coverage}; the set of tests must avoid repetition of equivalent paths: \textbf{compactness}.

The concepts and ideas developed during this works will also be implemented in verigraph, a new tool for specification and verification of software that is based on graph grammars and category theory.
\pagebreak
\hfill \break
\textbf{Structure of the Thesis:}

\begin{description}
  \item[Chapter~\ref{ch:gts}:] In this chapter we present a brief introduction to category theory, focusing on the constructions the will be needed throughout this work.  We also review the basic notions of DPO graph transformation systems, as well as the notions of parallel and sequential independency of rules.

\iffalse
  \item[Chapter~\ref{ch:concurrent-rules}:] In this chapter we present the construction of concurrent rules in addition to the problems that may arise from their calculation. Moreover, we present techniques that can be used to work around the problems.
\fi

  \item[Chapter~\ref{ch:process}:] In this chapter we present an overview of doubly-typed graph grammars and other constructions necessary to accomplish occurrence graph grammars, and how occurrence graph grammars can be used to represent the concurrent semantics of a graph grammar.

    We also extend previous works in occurrence graph grammars to include the notion of negative application conditions, which are commonly used in the modelling of systems as graph transformations systems nowadays.

  \item[Chapter~\ref{ch:verigraph}:] This chapter presents an overview of the verigraph tool, which was used to implement implement the techniques presented in this thesis. Both the reviewed on chapter~\ref{ch:gts} and presented on ~\ref{ch:process}.

  We present its architecture and novelty, as well as its suitability to deal with the problem domain in an elegant fashion.

  \item[Chapter~\ref{ch:tests}:] This chapter briefly introduces a methodology to extract graph grammar models from the use use cases of a system, after what it presents how we can use the concepts explained in previous chapters to generate a set of test cases.

    Specifically, we show how to extract test cases from calculated occurrence graph grammars, which was implemented on verigraph, and the reasons why the generated set of tests are relevant.

  \item[Chapter~\ref{ch:related-work}:] In this chapter, we present and compare our work to similar works found in the literature, focusing both in tools to model and use graph grammars and on the generation of test cases based on models and formal methods.

  \item[Chapter~\ref{ch:conclusions}:] This chapter summarizes our results and presents the conclusions. Moreover, it shows remaining open problems and future work.

  \item[Appendix~\ref{app:tutorial}:] This appendix contains the verigraph manual, explaining in the details how the tool can be downloaded, installed and used.

  \item[Appendix~\ref{app:marvel-grammar}] This appendix contains the use cases and modelled graph grammar used as case study on section~\ref{ch:tests}.
\end{description}
