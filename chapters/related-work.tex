\chapter{Related Work}\label{ch:related-work}

There exists a wide range of model-based techniques to test generation~\cite{Utting2006}, however due to the scope of our work we will focus on those based on graph transformation systems.

The advantages of graph transformation systems over other models are...

\section{Unfolding}

Code generators are tools used to translate graphical specifications of systems directly into executable code. According to \cite{Baldan2004}, they are widely used in the development of embedded software, e.g. in the automotive sector, however they lack the maturity and testing when compared to compilers of standard programming languages.

According to them, one of the biggest problems in testing code generators is the difficulty to describe the transformation rules from the graphical model to the target language as well as the interactions amongst them in a precise and formal way. Therefore, the authors propose a graph transformation based approach for systematically deriving test cases in this particular scenario.

Their approach is based on the use of unfolding of graph transformation systems~\cite{Ribeiro1996} over two graph grammars, a \textit{generating grammar}, responsible for generating all possible input models, and an \textit{optimising grammar}, which formalises specific transformation steps towards code optimization.

The main purpose is to test the optimization phase, in an attempt to ensure no mistakes will be introduced by improving the code while preserving its behaviour. In this context, a test case for a subset of optimizing rules $R$ is an input model $G$ such that all the rules in $R$ can be computed over $G$. This is similar to our approach where, for a sequence to be executed, all the rules in that sequence must be applicable, however we also use the non-applicable ones in order to generate test
cases where the application should fail.

Their approach has also some limitations, it is focused on testing optimization of code generation, not the code generation in itself; the NACs used extend the match with only one edge and are weaker than general nacs, although they consider isolated nodes as irrelevant and being ``garbage collected''.


%Advantages: test of non-deterministic systems. While our approach can probably be extended to test non-deterministic systems, no attempts 
%acyclic graphs and maximal depth of the unfolding

\section{Visual Contracts}

An approach proposed by~\cite{Heckel2011},~\cite{Khan2012},~\cite{Khan2012a},~\cite{Runge2013} focusing mainly on generating test cases for service-oriented or component-based systems. Given that systems of this kind often hide their implementation, the authors use interface descriptions known as visual contracts\footnote{ Formally regarded as graph transformation rules with operation signatures}, in order to model the observable behaviour of the system.

Coverage criteria is defined by means of static analysis, where potential conflicts and dependencies amongst visual contracts are calculated and used to build a dependency graph. In this situation, despite of being called ``a dependency graph'', this structure is rather similar to our occurrence relation, summarizing the results of both conflict and dependency analysis while representing the possible orderings in which the visual contracts may be executed.

In the processes of generating test cases, it is necessary to provide also an initial graph, which is used to find out which visual contracts are applicable to it. One of such visual contracts is chosen as the first step and all the paths through the dependency graph in which each rule is applied at most once are computed and stored as a set of rule sequences. Thereafter, the sequences are enriched to encompass rules with multiple dependencies and lately redundant rules contained in larger ones are
removed. Afterwards, each sequence is executed (if possible), and any new edges in the dependency graph reached by them are added to coverage. The entire process is then repeated as long as the coverage shows improvements. 

In comparison to our work, this approach has both advantages and limitations. As an example of the first, there are: the possibility to work with attributed typed graph transformation systems and multi-rules. As for the second: it requires more user involvement during the process of test case generation, it does not enclose negative application conditions, it was planned to work in a configuration where each rule is applied at most once and although being an extension of
AGG~\cite{Taentzer2000}, the tool is not available to download.

\section{Other Tools}

Overview and Comparison with other tools

\begin{itemize}
\item AGG
\item Groove
\item Henshin
\item AutoGraph
\item Deckwerth Framework
\end{itemize}

\section{Other methods for model-based test generation}

\begin{itemize}
  \item Finite State Machines
  \item UML
  \item Pre/Post Models
\end{itemize}

