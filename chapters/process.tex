\chapter{Graph Processes}

\section{Motivation}

Why do we use it to generate tests?

To a more in depth-explanation, see~\cite{Ribeiro1996, Corradini2014} 

\section{Doubly-Typed Graph Grammars}

\begin{definition}[Doubly-Typed Graph] Given a type graph $T$, a \emph{doubly-typed graph} \doublyTypedGraph{} over $T$ is a tuple \doublyTypedGraph $= \left(G^T, t^{G^T},TG^T\right)$ where $G^T$ and $TG^T$ are typed graphs over $T$ and \mbox{$t^{G^T} : G^T \rightarrow TG^T$} is a typed graph morphism in \typedGraphCategory{}. We call $TG^T$ the \emph{double-type graph} and $t^{G^T}$ the double-typing morphism.

\end{definition}

\begin{definition}[Doubly-Typed Graph Morphisms]
  Given two doubly-typed graphs $G^{TG^T}$ and $H^{TG^T}$ and a graph morphism $g^T : G^T \rightarrow H^T$, we say that $g^T$ is a \emph{$TG^T$-doubly-typed graph morphism} if the following diagram commutes:

\diagram{
  G\ar[rr]^{g}\ar[d]_{t^{G}}& & H\ar[d]^{t^{H}} \\
  TG\ar[rr]^{id}\ar[dr]_{type_{TG}} & &TG\ar[dl]^{type_{TG}} \\
  & T &
}
\end{definition}

Notice that the type morphisms $type_G : G \rightarrow T$ and $type_H : H \rightarrow T$ can be obtained respectively as $type_{TG} \circ t^G$ and $type_{TG} \circ t^H$.

\begin{remark} Although there are different kinds of doubly-typed graph morphisms depending on whether the doubly-type graphs and the type graphs are the different, we are here only interested in the case where the doubly-typed graphs share the same double-type and type graphs. Therefore we will call \mbox{\emph{$TG^T$-doubly-typed graph morphisms}} simply by \emph{doubly-typed graph morphisms} through the rest of this work.

\end{remark}

\begin{definition}[Doubly-Typed Graph Grammars] A \emph{doubly-typed graph grammar} is a tuple $GG = \left(TG^T, I^{TG^T},P \right)$ where $TG^T$ is the double-type graph of the grammar, $I^{TG^T}$ is a doubly-typed graph corresponding to the \emph{initial graph} of the grammar and $P$ is a set of doubly-typed graph rules. 
\end{definition}

\begin{definition}[Doubly-Typed Graph Rule] Given a double-type graph $TG^T$, a doubly-typed rule with respect to $TG^T$ is a span of morphisms \doublyTypedRule{} in \doublyTypedGraphCategory{} iff $p$ is a rule in \typedGraphCategory{} (see Definition~\ref{def:graph-rule})\tinytodo{$p$ or $p^T$?}. Also, given a doubly-typed graph rule \doublyTypedRule{} its inverse rule is defined by \inverseDoublyTypedRule{}.

  Let the typing morphisms from $L^{TG^T}$, $K^{TG^T}$ and $R^{TG^T}$ be $t^{L^T}$, $t^{K^T}$ and $t^{R^T}$, respectively. For a rule $a = p^{TG^T}$ we call:

  \begin{itemize}
    \item $L_a = L_T$, $K_a = K_R$ and $R_a = R_T$, the left, gluing and right graphs of $a$.
    \item $pre_a = t^{L^T} : L^T \rightarrow TG^T$, the \emph{pre-condition} of the $a$.
    \item $post_a = t^{R^T} : R^T \rightarrow TG^T$, the \emph{post-condition} of $a$.
    %\item $r_a = r^T$, the \emph{rule pattern} of $a$.\tinytodo{Not sure if we will need the rule pattern.}
  \end{itemize}
\end{definition}

\begin{definition}[Negative Application Conditions on Doubly-Typed Graph Rules] A \emph{left} negative application condition over a doubly-typed graph rule $p^{TG^T}$ is of the form $NAC(n)$, where $n^T : L^T \rightarrow N^T$ is an arbitrary (single-)typed graph morphism. A  (doubly-typed) match $m^{TG^T} : L^{TG^T} \rightarrow G^{TG^T}$ of a rule $p^{TG^T}$ satisfies $NAC(n^T)$ on $L^{TG^T}$, written \mbox{$m \models NAC(n)$}, iff $\nexists$ $q^T : N^T \rightarrow G^T$ where $q^T$ injective and $q^T \circ n^T = m^T$.

\diagram{
  T & TG\ar[l]\\
  N\ar[u]\ar@{.>}[dr]|{|}_{q} & L\ar[u]\ar[d]^{m}\ar[l]_{n}\\
   & G\ar@/_2.1pc/[uu]
}

  A match $m^{TG^T} : L^{TG^T} \rightarrow G^{TG^T}$ satisfies a set \mbox{$NAC_L = \{NAC\left(n_i\right)|i \in I\}$} of left $NACs$, iff \mbox{$m \models NAC\left(n_i\right)$} $\forall i \in I$.

\emph{Right} negative application conditions are defined analogously for the right hand side of a rule and its comatch.


\end{definition}

\begin{remark}
  Although we could have defined NACs that are also doubly-typed graph morphisms, which would then act specifically over doubly-typed graphs, we will not use this in our work graph. Therefore, we will use this \emph{single-typed} NACs as the only NAC type in all of our \emph{doubly-typed graph grammars}.
\end{remark}

\begin{definition}[Core Graph] Given a doubly-typed graph grammar \doublyTypedGraphGrammarCore{}, we have that \coreGraph{} is a \emph{core graph} iff \mbox{$\forall x \in$ \coreGraph $: \exists! y \in (I^T \uplus (\uplus_{i \in P} (R_i - K_i))$}.


\[ x =
    \begin{cases}
      in_{GG}\parens{y},$ if $y \in I^T\\
      post_i(y),$ if $y \in R_i - K_i\\
    \end{cases}
   \]\tinytodo{check whether this definition is correct/complete}

  \begin{intuition} The idea is that each element in the \emph{Core Graph} has a unique origin either being present in the initial graph or being created by a single rule.
\end{intuition}


\end{definition}

\begin{definition}[Strongly Safe (Doubly-Typed) Graph Grammars] Given \doublyTypedGraphGrammarCore{} a doubly-typed graph grammar, $GG$ is said to be \emph{strongly safe} if its double-type graph is also a core graph.

Also, each rule in a strongly safe graph grammar whose double-type is also a core graph is called an \emph{action}. An action $a$ \emph{creates} an element $e$ iff $e \in R(a) - K(a)$. Similarly, $a$ \emph{deletes} $e$ iff $e \in L(a) - K(a)$.
\end{definition}

\section{Relations within Strongly Safe Graph Grammars}

Given that a Core Graph contains all elements used (created, read or deleted) during the execution of a grammar and that each element has an unique origin within it, the Core Graph can be considered to contain the entire ``execution history'' of its underlying grammar. 

We are here interested in some of the properties that can be found by looking at this history. Particularly, the relationships among actions, among elements, and among actions and elements.

\begin{remark}[Different Graph Transformation interpretation] When dealing with actions, we will use a slightly different interpretation of the graph transformations. Given an action \emph{a}, we have that:
  
\diagram{
  L\ar[d]_{pre_a}        & & K\ar[ll]_{l}\ar[rr]^{r}\ar[d]|{k} & & R\ar[d]^{post_a}\\
  C^T_{|L}\ar@{}[urr]|{\left(1\right)} & & C^T_{|K}\ar[ll]^{f}\ar[rr]_{g}             & & C^T_{|R}\ar@{}[ull]|{\left(2\right)}
}
\hfill %\break

The first difference is that elements created or deleted by the underlying rule of an action are not merely typed over the core graph, but in fact exactly the ones in the core graph. Second, the elements in $pre_a - k_a$ and $post_a - k_a$ are not really deleted nor created, they must always be present in the core graph as it maintains the history of execution. Nonetheless, their creation (resp. deletion) would be performed in an execution of the simply-typed grammar. Here, for the sake of
  simplicity, we overload these terms and continue to refer to this elements as deleted/created.

  Also, for practical purposes, we restrict the codomain of the pre-, post- and gluing morphisms of an action to their respective images, such as $pre_a : L \rightarrow C^T_{|L}$. This point will be returned later on when dealing with negative application conditions\tinytodo{Do not forget to explain this in the proper session}.
\end{remark}

In~\cite{Ribeiro1996}, the causal and conflict relations for strongly safe graph grammars were defined. There, the graph transformation approach used was the \emph{Single Pushout} (SPO) without NACs. \cite{Corradini1996} also defined a similar notion of causal relation with respect to the DPO approach without NACs.

Both authors use these relations to find out whether all actions of a strongly safe graph grammar are applicable and prove some properties about it. However, this relations alone are no sufficient to this purpose when the actions may have NACs, which are nowadays essential for modelling complex systems~\cite{Corradini2014}.

Here we recall these definitions, which correspond to the \emph{existential relation} and the \emph{unconditional causal dependency and conflict relations} defined in the following, and extend them to create an equivalent notion of \emph{conditional relations} that work for grammars in the DPO approach with NACs.

\begin{definition}[Existential Relation] This is the \emph{causal relation} defined in \cite{Corradini1996} for the DPO approach without NACs. Given  \doublyTypedGraphGrammarCore{} a strongly safe graph grammar. Let actions $a_1, a_2 \in P, a_1 \ne a_2$ and element \mbox{$e_1 \in $ \coreGraph{}}, then:

  \begin{enumerate}
    \item If $a_1$ deletes $e_1$, then $e_1 <_e a_1$.
    \item If $a_1$ creates $e_1$, then $a_1 <_e e_1$.
    \item If $a_1$ creates $e_1$ and $p_2$ preserves $e_1$, then $a_1 <_e a_2$.
    \item If $a_1$ preserves $e_1$ and $a_2$ deletes $e_1$, then $a_1 <_e a_2$. 
    \item The \emph{existential relation} $(P \cup E, \leq_e)$ is the reflexive and transitive closure of $<_e$.
  \end{enumerate}
\end{definition}

This relation represents restrictions over creation, use (preservation) and deletion of elements by actions that must be respected for the actions to be applicable. In the sense that an action $a$ must occur after all the actions that create the elements which it depends on. Similarly, $a$ must occur before all actions that delete those same elements.

\begin{example}[Existencial Relation Example]
\end{example}

In \cite{Corradini1996} it is shown that if this relation is a partial order, then all productions of the underlying grammar are applicable. However, this condition is not sufficient in grammars with NACs.

\begin{example}[Failing existencial relation with nacs]
\end{example}

The next unconditional relations are equivalent to the relations presented at~\cite{Ribeiro1996}, but for the DPO approach. Both cases of dependency relations defined below are based on the following intuition:

\begin{intuition} An action $a_1$ is a direct cause of an action $a_2$ if either $a_1$ creates some element that is needed by $a_2$ (unconditional causal dependency) or $a_1$ deletes an element that is both forbidden by a NAC of $a_2$ and existent before the application of $a_2$ (conditional causal dependency). In both cases, we have that $a_2$ can only happen after $a_1$.\tinytodo{Explain that we do not use the notion of irreversible dependency, as we are interested only in the ordered
  execution of the actions?} 
\end{intuition}

\begin{definition}[Unconditional Causal Dependency Relation\footnote{Also be called Produce-Use Relation}] Given \doublyTypedGraphGrammarCore{} a doubly-typed graph grammar and \coreGraph{} a core graph. Let $a_1, a_2 \in P, a_1 \ne a_2$ and \mbox{$e_1, e_2 \in $ \coreGraph{},} $e_1 \ne e_2$. Then: 

  \begin{enumerate}
    \item The action $a_2$ is \emph{directly causally dependent} on $a_1$, written $a_1 <_{pu} a_2$, iff \mbox{$\not\exists h_{21} : L_2 \rightarrow D_1$ s.t. \mbox{$d_1 \circ h_{21} = pre_2$}}, where the two squares are pushouts and $C^T_{|R_1L_2}$ ($C^T$ restricted to the jointly-image of $post_1$ and $pre_2$) satisfies the NACs for $a_2$ and $a_1^{-1}$.

\diagram{
  L_1 & K_1\ar[d]\ar[l]\ar[r] & R_1\ar[dr]_{post_1} & & L_2\ar@{.>}@/_1.1pc/[dlll]|{|}_<<<<{h_{21}}\ar[dl]^{pre_2} & K_2\ar[l]\ar[r]\ar[d] & R_2\\
       & D_1\ar@{^{(}->}[rr]_{d_1} & & C^T_{|R_1L_2} & & D_2\ar@{_{(}->}[ll] &}

   \item The \emph{causal dependency relation between actions} $(P, \leq_{pu})$ is the reflexive and transitive closure of the direct causal dependency.
   \item The element $e_2$ is \emph{directly causally dependent} on $e_1$, written $e_1 <_{pu} e_2$, iff there is an action $a_1 \in P$ such that $a_1$ deletes $e_1$ and creates $e_2$.
   \item The \emph{causal dependency relation between elements} $(E, \leq_{pu})$ is the reflexive and transitive closure of the direct causal dependency.
   \item The \emph{unconditional causal dependency relation} of a strongly safe grammar is defined by $(P \cup E, \leq_{pu})$.
  \end{enumerate}
\end{definition}


As for the conflicts, the relations defined below are based on the following intuition: 

\begin{intuition} An action $a_1$ is in \emph{weak} conflict with an action $a_2$ if either $a_1$ deletes something that is needed by $a_2$ to be applied (unconditional weak conflict) or creates something that is both forbidden by a NAC of $a_2$ and not deleted before the application of $a_2$ (conditional weak conflict). In both cases, we have that $a_2$ can not happen once $a_1$ has happened, in other words: $a_2$ can only happen before $a_1$\footnote{Unless a third rule deletes the forbidden
  element(s) between the applications of $a_1$ and $a_2$. This point will be returned later on.}.
\end{intuition}


\begin{definition}[Unconditional Weak Conflict Relation\footnote{Also called Delete-Use Relation.}] Given \doublyTypedGraphGrammarCore{} a doubly-typed graph grammar and \coreGraph{} a core graph. Let $a_1, a_2 \in P, a_1 \ne a_2$ and \mbox{$e_1, e_2 \in $ \coreGraph{},} $e_1 \ne e_2$. Then: 

  \begin{enumerate}
    \item The action $a_1$ is in \emph{direct weak conflict} with $a_2$, written $a_2 <_{du} a_1$, iff \mbox{$\not\exists h_{12} : L_1 \rightarrow D_2$} s.t. \mbox{$d_2 \circ h_{12} = pre_1$}.

      \diagram{
        R_1 & K_1\ar[l]\ar[r]\ar[d] & L_1\ar[dr]_{pre_1} & & L_2\ar[dl]^{pre_2}\ar@{.>}@/_1.1pc/[dlll]|{|}_<<<<{h^{21}} & K_2\ar[l]\ar[r]\ar[d] & R_2\\
       & D_1\ar[rr]_{d_1} & & C^T & & D_2\ar[ll] &}
   \item The \emph{weak conflict relation between actions} $(P,\leq_{du})$ is the reflexive and transitive closure of the direct weak conflict.
   \item The element $e_2$ is in weak conflict with $e_1$, written $e_2 <_{du} e_1$, iff there are actions $a_1$ and $a_2$ that respectively create $e_1$ and $e_2$ and $a_2$ is in a weak conflict with $a_1$.
   \item The \emph{weak conflict relation between elements} $(P \cup E, \leq_{du})$ is the reflexive and transitive closure of $<_{du}$.
  \end{enumerate}
\end{definition}

It is important to recall that the relationships extracted from strongly safe grammars whose underlying actions do not have NACs are always concrete, in the sense that if an action is dependent on (conflicting with) another one, it happens because the first one creates (resp. deletes) at least one of the elements necessary for the second to be applied.

On the other hand, each dependency or conflict induced by NACs may be always \emph{concrete}, \emph{non existent}, or conditioned to a specific order of application (\emph{abstract}), for example: 

Let $a_1, a_2, a_3$ be three actions of the same doubly-typed grammar. Suppose that $a_1$ creates elements used by $a_2$ and $a_2$ creates elements used by $a_3$. 
Now suppose that when $a_2$ is applied, it creates an element that would be forbidden by a NAC of $a_1$ and also that $a_3$ deletes this element. 

By the classical notions of dependency and conflict with NACs, as shown in definitions~\ref{def:classic-dependency} and~\ref{def:classic-conflict}, $a_2$ would conflict with $a_1$ and $a_1$ would be dependent on $a_3$. However, by creation and deletion of necessary elements, there is only one order in which this rules can be applied: $a_1,a_2,a_3$.

This configuration ensures that there is no conflict between $a_1$ and $a_2$, as the element that would be forbidden by the NAC of $a_1$ can only exist after $a_1$ itself was already applied. Similar reasoning is applied to the potential dependency that is identified because $a_3$ deletes the element that would be forbidden by the NAC of $a_1$.
\tinytodo{Draw the examples for non-existent (last paragraph), concrete and potential dependencies/conflicts}

Given that $a_1, a_2 \in P$ are in a potential dependency of the type delete-forbid or a potential conflict of the type produce-forbid, we want to know when this dependency/conflict can be considered to be \emph{concrete}, \emph{non existent} or \emph{abstract}.

The problem with conditional relations in the core graph\tinytodo{expand}\tinytodo{define and explain the notion of incremental negative application conditions~\cite{Corradini2013}}

\begin{definition}[Conditional Causal Dependency Relation\footnote{Also called Delete-Forbid Relation}] Let \doublyTypedGraphGrammarCore{} be a doubly-typed graph grammar, \coreGraph{} a core graph and $P$ a set of rules with incremental, non-trivially triggered NACs only.


\diagram{
  & & N^{-1}_1 & & N_2 & &\\
  L_1\ar[d] & K_1\ar[d]\ar[l]\ar[r] & R_1\ar[u]^{n_1}\ar[dr]_{post_1} & & L_2\ar[u]_{n_2}\ar@{.>}@/_1.1pc/[dlll]_<<<<{h_{21}}\ar[dl]^{pre_2} & K_2\ar[l]\ar[r]\ar[d] & R_2\\
     C^T_{|L_1D_1} & D_1\ar[rr]_{d_1}\ar[l]^{e_1} & & C^T_{|R_1L_2} & & D_2\ar[ll] &}
\hfill

Let $a_1$ delete from graph \coreGraph{} an element $x \in N($\coreGraph$) \cup E($\coreGraph$)$ that potentially triggers a NAC $N_2$ of $a_2$. There are three possible cases to look at:

\begin{enumerate}
  \item $a_2$ is somehow related to $x$ by the concrete occurrence relation.
  \item $a_2$ is not related to $x$ by the concrete occurrence relation, but $x$ is present in the initial graph.
  \item $a_2$ is not related to $x$ by the concrete occurrence relation and $x$ is not present in the initial graph.
\end{enumerate}

  First, let $x$ be related to $a_2$ by the unconditional occurrence relation\tinytodo{define this or extend corradini's}, i.e. \mbox{$x \leq a_2 \lor a_2 \leq x$}. If $a_2 \leq x$ it means that $x$ was either created by $a_2$ or by another action that must to occur after $a_2$. Thus, the delete-forbid dependency in this case can \emph{does not exist} as the element $x$ did not exist to trigger $N_2$ before $a_2$ was applied. On the other hand, if $x \leq a_2$, then $x$ exists before $a_2$
  application and must be deleted in order for $a_2$ to be applied, therefore this delete-forbid is \emph{concrete} and $a_1 <_{df} a_2$ .

  Second, let $x$ be not related to $a_2$ at the same time that it is not created by any rule in $P$, meaning that $x$ is present on the initial graph: $x \in I^{C^T}$. In such configuration, the delete-forbid is also \emph{concrete}, once $x$ existed before $a_2$, preventing its application. Therefore, we have $a_1 <_{df} a_2$.

  Third, let $x$ be not related to $a_2$, but created by a third action $a_3 \in P$, $a_1 \ne a_3 \ne a_2$\footnote{Notice that in this configuration, $a_3 <_{pu} a_1$.}, and let $a_3$ be not related to $a_2$ by the concrete occurrence relation. In this case, we may have that $a_1 < a_2$ by delete-forbid if we choose a configuration where $a_3$ is applied before $a_2$.
  
  If $a_3$ were related to $a_2$ and $a_3$ creates $x$, then $a_2$ would be related to $x$, which corresponds to the first case.


\end{definition}

\begin{definition}[Conditional Weak Conflict Relation\footnote{Also called Produce-Forbid Relation}] Let \doublyTypedGraphGrammarCore{} a doubly-typed graph grammar, \coreGraph{} a core graph and $P$ a set of rules with incremental, non-trivially triggered NACs only.

  Given $a_1,a_2 \in P$, where $a_1$ creates on graph $C^T$ an element $x \in N(C^T) \cup E(C^T)$ that potentially triggers a NAC $N_2$ of $a_2$. There are two possible cases to look at:

  \begin{enumerate}
    \item $a_2$ is somehow related to $x$ by the concrete occurrence relation.
    \item $a_2$ is not related to $x$ by the concrete occurrence relation.
  \end{enumerate}

  In the first case, if $a2 \leq x$ it means that $x$ is created only after $a_2$ has been applied, therefore this configuration of produce-forbid can not be concrete as the trigger element does not occur at the moment of $a_2$ application. On the other hand, if $x \leq a_2$ it means that $x$ existed before $a_2$ was applied, which leads to two possible subcases: (1) there is another action $a_3$ that deletes $x$, which means that the $a_1$ and $a_2$ are in produce-forbid conflict, but this
  conflict is ``annulated'' by the application of $a_3$, which must then happen before $a_2$ or (2) there is no other rule that deletes $x$, which means that rules are in
  produce-forbid conflict.
\end{definition}

\begin{definition}[Concrete Occurence Relation] The union of unconditional dependency and conflict relations, which are always concrete, and the concrete concrete conditional dependency and conflict relations.
\end{definition}

\begin{definition}[Abstract Occurence Relation] The union of the abstract conditional dependency and abstract conditional conflict relations.
\end{definition}

\begin{definition}[Occurrence Relation]
\end{definition}

\begin{definition}[Occurrence Graph Grammars]
\end{definition}

\begin{definition}[Concurrent Graphs]
\end{definition}

\section{Calculating Graph Process}

\subsection{Graph Process without NACs}

\begin{definition}[Colimit construction]
\end{definition}

\subsection{Graph Process with NACs}

\begin{definition}[Incremental NACs] Given a monomorphism \mbox{$f : A \rightarrow B$}, $f$ is said to be incremental if for any possible pair of decompositions \mbox{$g_1 : A \rightarrow O_g;g_2 : O_g \rightarrow B$} and \mbox{$h_1 : A \rightarrow O_h;h_2 : O_h \rightarrow B$} as in the diagram below, where all morphisms are monos and $g = f = h$, there exists a mediating morphism $o_1 : O_g \rightarrow O_h$ or $o_2 : O_h \rightarrow O_g$, such that the resulting triangles commutes.


\diagram{
  & O_g\ar[dr]^{g_2}\ar@{.>}@/_0.5pc/[dd]|<<<<<<{o_1} &  \\
  A\ar[ur]^{g_1}\ar[dr]_{h_1}\ar[rr]|<<<<{f}&     & B\\
    & O_h\ar[ur]_{h_2}\ar@{.>}@/_0.5pc/[uu]|<<<<<<<<{o_2} & 
}

\end{definition}

\begin{definition}[Colimit construction with Incremental NACs]
\end{definition}
