\chapter{Generating Test Cases}\label{ch:tests}

In this chapter, we show how to use occurrence graph grammars to generate test cases from (simply-typed) graph grammars that model systems. In theory, this technique can be used to generate tests for any graph grammar, however we will use in our examples grammars that were generated using the methodology presented in \cite{Junior2015} and \cite{BezerraWEIT2016}.

This methodology is a systematic, computer-aided way to extract graph grammars from use cases and other text-based requirement documents. Thus, by generating tests from these grammars, we are generating tests for the use cases of a system.

Regarding the generation of test cases, we first need to know whether each functionality is executable, i.e. whether all the rules in the subset are applicable. In the positive case, we want to know the input and output data necessary for this functionality, an ordering in which all the rules can be applied in order to fulfill the functionality goals, and which are the valid intermediate states the system may have. In the negative case, we want to know why this functionality can not be executed.

\section{Overview of the original methodology}

Figure~\ref{fig:tests:methodology} summarizes the methodology process.

\begin{figure}[!ht]
  \centering
  \fbox{\includegraphics[scale=0.6]{images/generating-tests/methodology}}
  \caption{Overview of the methodology~\cite{Junior2015}.}\label{fig:tests:methodology}
\end{figure}

\section{Calculating tests using Occurrence Graph Grammars}

Given a graph grammar \graphGrammar{} modelling a system $X$ with $n > 0$ functionalities, we want to generate a test case for each subset of rules $F_i \subseteq P$ $\forall i \in 1\ldots n$, where $F_i$ represents a complete functionality \tinytodo{feature} of the system $X$.

Together with the grammar $GG$ and its subsets of functionalities $F_i$, we will also need an \emph{input-output relation} $IO_i$ for each $F_i$, specifying the connections between the rules involved in the feature. This \emph{input-output relation} specifies which elements (nodes and edges) must be the same among the rules, as shown in example~\ref{ex:inout}.


\begin{example}[Input-Output Relations]\label{ex:inout}
\end{example}

For the test cases generation we receive as input:

\begin{itemize}
\item set of rules $P$
\item subsets representing functionalities $F_i$
\item input-output relations $IO_i$ for each $F_i$
\end{itemize}

We want to generate as output:

\begin{itemize}
\item an amalgamation (colimit) $OGG_i$ of rules for each $F_i$ with respect to $IO_i$
\item the initial and final graphs $I_i$ and $J_i$ of $OGG_i$, representing the input and output data of the functionality $F_i$
\item the conflict and dependency relations between rules \tinytodo{and the elements involved in the conflict / dependency}
\item restrictions \tinytodo{remove or expand?}
\end{itemize}

\begin{example}[Amalgamation example]
\end{example}

\begin{example}[Initial and Final Graphs Example]
\end{example}

Once we have the output, we test whether $OGG_i$ is an occurrence graph grammar and $I_i, J_i$ are valid graphs.

\begin{example}[]
\end{example}

\section{Building test cases with Verigraph}

More specific usability details can be found on the Verigraph tutorial, whose current version is presented on appendix~\ref{app:tutorial}.
